"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForNodeToBeReady = waitForNodeToBeReady;
exports.waitForEthRpcToBeReady = waitForEthRpcToBeReady;
const axios_1 = __importDefault(require("axios"));
const constants_1 = require("../constants");
const errors_1 = require("../errors");
async function waitForNodeToBeReady(port, maxAttempts = 20) {
    const payload = {
        jsonrpc: "2.0",
        method: "state_getRuntimeVersion",
        params: [],
        id: 1,
    };
    await waitForServiceToBeReady(port, payload, maxAttempts);
}
async function waitForEthRpcToBeReady(port, maxAttempts = 20) {
    const payload = {
        jsonrpc: "2.0",
        method: constants_1.RPC_ENDPOINT_PATH,
        params: [],
        id: 1,
    };
    await waitForServiceToBeReady(port, payload, maxAttempts);
}
async function waitForServiceToBeReady(port, payload, maxAttempts) {
    let attempts = 0;
    let waitTime = 1000;
    const backoffFactor = 2;
    const maxWaitTime = 30000;
    const endpoint = `${constants_1.BASE_URL}:${port}`;
    while (attempts < maxAttempts) {
        try {
            const response = await axios_1.default.post(endpoint, payload);
            if (response.status == 200) {
                return;
            }
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
        }
        catch (_e) {
            // If it fails, it will just try again
        }
        attempts++;
        await new Promise((r) => setTimeout(r, waitTime));
        waitTime = Math.min(waitTime * backoffFactor, maxWaitTime);
    }
    throw new errors_1.PolkadotNodePluginError("Server didn't respond after multiple attempts");
}
//# sourceMappingURL=utils.js.map