"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getArtifactFromContractOutput = getArtifactFromContractOutput;
exports.getVersionComponents = getVersionComponents;
exports.updateDefaultCompilerConfig = updateDefaultCompilerConfig;
exports.pluralize = pluralize;
exports.extractCommands = extractCommands;
exports.extractImports = extractImports;
exports.mapImports = mapImports;
exports.orderSources = orderSources;
const constants_1 = require("hardhat/internal/constants");
const npm_1 = require("./compile/npm");
const errors_1 = require("./errors");
function getArtifactFromContractOutput(sourceName, contractName, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
contractOutput) {
    const evmBytecode = contractOutput.evm?.bytecode;
    const bytecode = evmBytecode?.object ?? "";
    const evmDeployedBytecode = contractOutput.evm?.deployedBytecode;
    const deployedBytecode = evmDeployedBytecode?.object ?? "";
    const linkReferences = evmBytecode?.linkReferences ?? {};
    const deployedLinkReferences = evmDeployedBytecode?.linkReferences ?? {};
    return {
        _format: constants_1.ARTIFACT_FORMAT_VERSION,
        contractName,
        sourceName,
        abi: contractOutput.abi,
        bytecode,
        deployedBytecode,
        linkReferences,
        deployedLinkReferences,
    };
}
function getVersionComponents(version) {
    const versionComponents = version.split(".");
    return [
        parseInt(versionComponents[0], 10),
        parseInt(versionComponents[1], 10),
        parseInt(versionComponents[2], 10),
    ];
}
function updateDefaultCompilerConfig(solcConfigData, resolc) {
    const compiler = solcConfigData.compiler;
    const settings = compiler.settings || {};
    let optimizer = {};
    if (resolc.settings?.optimizer && resolc.settings?.optimizer?.enabled) {
        optimizer = Object.assign({}, resolc.settings?.optimizer);
    }
    else if (resolc.settings?.optimizer?.enabled === false) {
        optimizer = Object.assign({}, { enabled: false, runs: 200 });
    }
    else {
        optimizer = Object.assign({}, { enabled: false, runs: 200 });
    }
    compiler.settings = {
        ...settings,
        optimizer: { ...optimizer },
        outputSelection: {
            "*": {
                "*": ["abi"],
            },
        },
        evmVersion: compiler.settings.evmVersion,
        resolc: resolc,
    };
    const [major, minor] = getVersionComponents(compiler.version);
    if (major === 0 && minor < 7) {
        throw new errors_1.ResolcPluginError(`Solidity versions below 0.8.0 are not supported. Trying to use ${compiler.version}`);
    }
    if (resolc.compilerSource === "npm") {
        (0, npm_1.updateSolc)(compiler.version);
    }
}
function pluralize(n, singular, plural) {
    if (n === 1) {
        return singular;
    }
    if (plural !== undefined) {
        return plural;
    }
    return `${singular}s`;
}
function extractStandardJSONCommands(config, commandArgs) {
    const settings = config.settings;
    commandArgs.push(`--standard-json`);
    if (settings.solcPath) {
        commandArgs.push(`--solc=${settings.solcPath}`);
    }
    if (settings.basePath) {
        commandArgs.push(`--base-path=${settings.basePath}`);
    }
    if (settings.includePaths) {
        commandArgs.push(`--include-paths=${settings.includePaths}`);
    }
    if (settings.allowPaths) {
        if (!settings.basePath) {
            throw new errors_1.ResolcPluginError(`--allow-paths option is only available when --base-path has a non-empty value.`);
        }
        commandArgs.push(`--allow-paths=${settings.allowPaths}`);
    }
    if (settings.debugOutputDir) {
        commandArgs.push(`--debug-output-dir=${settings.debugOutputDir}`);
    }
    if (settings.emitDourceDebugInfo) {
        commandArgs.push(`-g`);
    }
    return commandArgs;
}
function extractCommands(config) {
    const commandArgs = [];
    return extractStandardJSONCommands(config, commandArgs);
}
function extractImports(fileContent) {
    const importRegex = /import\s+(?:"([^"]+)"|'([^']+)'|(?:[^'"]+)\s+from\s+(?:"([^"]+)"|'([^']+)'))\s*;/g;
    const imports = [];
    let match;
    while ((match = importRegex.exec(fileContent)) !== null) {
        const importedPath = match[1] || match[2] || match[3] || match[4];
        if (importedPath) {
            imports.push(importedPath);
        }
    }
    return imports;
}
function mapImports(input) {
    const keys = Object.keys(input.sources);
    const map = new Map();
    for (const key of keys) {
        const importArray = extractImports(input.sources[key].content);
        map.set(key, importArray);
    }
    return map;
}
function orderSources(mapped) {
    const ordered = [];
    mapped.forEach((values, key) => {
        for (const value of values) {
            if (ordered.includes(value))
                continue;
            ordered.push(value);
        }
        if (ordered.includes(key))
            return;
        ordered.push(key);
    });
    return ordered;
}
//# sourceMappingURL=utils.js.map